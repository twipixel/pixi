<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>WebGL Matrix</title>
    <script type="text/javascript" src="../../libs/dat.gui.js"></script>
    <style>
      body {
        background-color: #fff;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

      canvas {
        border: solid 1px #999;
      }
    </style>
  </head>
  <body>
    <div id="wrap" class="section">
      <h2>WebGL Matrix</h2>
      <canvas id="canvas" width="600" height="600"></canvas>
    </div>
    <script type="module">
      // https://webgl2fundamentals.org/webgl/lessons/ko/webgl-2d-matrices.html

      import {
        createProgramFromSources,
        resizeCanvasToDisplaySize,
      } from '../../libs/webgl-utils.js';

      const gui = new dat.GUI();

      const vertexShaderSource = `#version 300 es

                  // an attribute is an input (in) to a vertex shader.
                  // It will receive data from a buffer
                  in vec2 a_position;

                  // A matrix to transform the positions by
                  uniform mat3 u_matrix;

                  // all shaders have a main function
                  void main() {
                    // Multiply the position by the matrix.
                    gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);
                  }
                `;

      const fragmentShaderSource = `#version 300 es

                  precision highp float;

                  uniform vec4 u_color;

                  // we need to declare an output for the fragment shader
                  out vec4 outColor;

                  void main() {
                    outColor = u_color;
                  }
                `;

      function main() {
        var canvas = document.querySelector('#canvas');
        var gl = canvas.getContext('webgl2');
        if (!gl) {
          return;
        }

        // Use our boilerplate utils to compile the shaders and link into a program
        var program = createProgramFromSources(gl, [
          vertexShaderSource,
          fragmentShaderSource,
        ]);

        // look up where the vertex data needs to go.
        var positionAttributeLocation = gl.getAttribLocation(
          program,
          'a_position'
        );

        // look up uniform locations
        var resolutionUniformLocation = gl.getUniformLocation(
          program,
          'u_resolution'
        );
        var colorLocation = gl.getUniformLocation(program, 'u_color');
        var matrixLocation = gl.getUniformLocation(program, 'u_matrix');

        // Create a buffer
        var positionBuffer = gl.createBuffer();

        // Create a vertex array object (attribute state)
        var vao = gl.createVertexArray();

        // and make it the one we're currently working with
        gl.bindVertexArray(vao);

        // Turn on the attribute
        gl.enableVertexAttribArray(positionAttributeLocation);

        // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        // Set Geometry.
        setGeometry(gl);

        // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
        var size = 2; // 2 components per iteration
        var type = gl.FLOAT; // the data is 32bit floats
        var normalize = false; // don't normalize the data
        var stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position
        var offset = 0; // start at the beginning of the buffer
        gl.vertexAttribPointer(
          positionAttributeLocation,
          size,
          type,
          normalize,
          stride,
          offset
        );

        // First let's make some variables
        // to hold the translation,
        var translation = [150, 100];
        var rotationInRadians = 0;
        var scale = [1, 1];
        var color = [Math.random(), Math.random(), Math.random(), 1];

        drawScene();

        const radiansToDegree = (radians) => (radians * 180) / Math.PI;

        const config = {
          x: translation[0],
          y: translation[1],
          angle: radiansToDegree(rotationInRadians),
          scaleX: scale[0],
          scaleY: scale[1],
        };

        gui.add(config, 'x', 0, gl.canvas.width).onChange(updatePosition(0));
        gui.add(config, 'y', 0, gl.canvas.height).onChange(updatePosition(1));
        gui.add(config, 'angle', 0, 360).onChange(updateAngle);
        gui.add(config, 'scaleX', -5, 5).onChange(updateScale(0));
        gui.add(config, 'scaleY', -5, 5).onChange(updateScale(1));

        function updatePosition(index) {
          return function () {
            translation[index] = index === 1 ? config.y : config.x;
            drawScene();
          };
        }

        function updateAngle() {
          var angleInDegrees = config.angle;
          rotationInRadians = (angleInDegrees * Math.PI) / 180;
          drawScene();
        }

        function updateScale(index) {
          return function () {
            scale[index] = index === 1 ? config.scaleY : config.scaleX;
            drawScene();
          };
        }

        // Draw the scene.
        function drawScene() {
          resizeCanvasToDisplaySize(gl.canvas);

          // Tell WebGL how to convert from clip space to pixels
          gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

          // Clear the canvas
          gl.clearColor(0, 0, 0, 0);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

          // Tell it to use our program (pair of shaders)
          gl.useProgram(program);

          // Bind the attribute/buffer set we want.
          gl.bindVertexArray(vao);

          // Pass in the canvas resolution so we can convert from
          // pixels to clipspace in the shader
          gl.uniform2f(
            resolutionUniformLocation,
            gl.canvas.width,
            gl.canvas.height
          );

          // Set the color.
          gl.uniform4fv(colorLocation, color);

          // Compute the matrices
          var matrix = m3.projection(
            gl.canvas.clientWidth,
            gl.canvas.clientHeight
          );
          matrix = m3.translate(matrix, translation[0], translation[1]);
          matrix = m3.rotate(matrix, rotationInRadians);
          matrix = m3.scale(matrix, scale[0], scale[1]);

          // Set the matrix.
          gl.uniformMatrix3fv(matrixLocation, false, matrix);

          // Draw the geometry.
          var primitiveType = gl.TRIANGLES;
          var offset = 0;
          var count = 18;
          gl.drawArrays(primitiveType, offset, count);
        }
      }

      // Fill the current ARRAY_BUFFER buffer
      // with the values that define a letter 'F'.
      function setGeometry(gl) {
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array([
            // left column
            0, 0, 30, 0, 0, 150, 0, 150, 30, 0, 30, 150,

            // top rung
            30, 0, 100, 0, 30, 30, 30, 30, 100, 0, 100, 30,

            // middle rung
            30, 60, 67, 60, 30, 90, 30, 90, 67, 60, 67, 90,
          ]),
          gl.STATIC_DRAW
        );
      }

      var m3 = {
        projection: function projection(width, height) {
          // Note: This matrix flips the Y axis so that 0 is at the top.
          return [2 / width, 0, 0, 0, -2 / height, 0, -1, 1, 1];
        },

        translation: function translation(tx, ty) {
          return [1, 0, 0, 0, 1, 0, tx, ty, 1];
        },

        rotation: function rotation(angleInRadians) {
          var c = Math.cos(angleInRadians);
          var s = Math.sin(angleInRadians);
          return [c, -s, 0, s, c, 0, 0, 0, 1];
        },

        scaling: function scaling(sx, sy) {
          return [sx, 0, 0, 0, sy, 0, 0, 0, 1];
        },

        multiply: function multiply(a, b) {
          var a00 = a[0 * 3 + 0];
          var a01 = a[0 * 3 + 1];
          var a02 = a[0 * 3 + 2];
          var a10 = a[1 * 3 + 0];
          var a11 = a[1 * 3 + 1];
          var a12 = a[1 * 3 + 2];
          var a20 = a[2 * 3 + 0];
          var a21 = a[2 * 3 + 1];
          var a22 = a[2 * 3 + 2];
          var b00 = b[0 * 3 + 0];
          var b01 = b[0 * 3 + 1];
          var b02 = b[0 * 3 + 2];
          var b10 = b[1 * 3 + 0];
          var b11 = b[1 * 3 + 1];
          var b12 = b[1 * 3 + 2];
          var b20 = b[2 * 3 + 0];
          var b21 = b[2 * 3 + 1];
          var b22 = b[2 * 3 + 2];
          return [
            b00 * a00 + b01 * a10 + b02 * a20,
            b00 * a01 + b01 * a11 + b02 * a21,
            b00 * a02 + b01 * a12 + b02 * a22,
            b10 * a00 + b11 * a10 + b12 * a20,
            b10 * a01 + b11 * a11 + b12 * a21,
            b10 * a02 + b11 * a12 + b12 * a22,
            b20 * a00 + b21 * a10 + b22 * a20,
            b20 * a01 + b21 * a11 + b22 * a21,
            b20 * a02 + b21 * a12 + b22 * a22,
          ];
        },

        translate: function (m, tx, ty) {
          return m3.multiply(m, m3.translation(tx, ty));
        },

        rotate: function (m, angleInRadians) {
          return m3.multiply(m, m3.rotation(angleInRadians));
        },

        scale: function (m, sx, sy) {
          return m3.multiply(m, m3.scaling(sx, sy));
        },
      };

      main();
    </script>
  </body>
</html>
