<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>WebGL Basic 2</title>
    <style>
      body {
        background-color: #fff;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

      canvas {
        border: solid 1px #999;
      }
    </style>
  </head>
  <body>
    <div id="wrap" class="section">
      <h2>WebGL Basic 2</h2>
      <canvas id="canvas" width="400" height="400"></canvas>
    </div>
    <script type="module">
      // https://webgl2fundamentals.org/webgl/lessons/ko/webgl-fundamentals.html#toc
      import { resizeCanvasToDisplaySize } from '../../libs/webgl-utils.js';

      const canvas = document.getElementById('canvas');
      const gl = canvas.getContext('webgl2');

      const vertexShaderSource = `#version 300 es

        // attribute는 정점 셰이더에 대한 입력(in)입니다.
        // 버퍼로부터 데이터를 받습니다.
        in vec2 a_position;

        uniform vec2 u_resolution;

        // 모든 셰이더는 main 함수를 가지고 있습니다.
        void main() {
          // 픽셀 위치를 0.0에서 1.0 사이 값으로 변환합니다.
          vec2 zeroToOne = a_position / u_resolution;

          // 0 -> 1에서 0 -> 2로 변환
          vec2 zeroToTwo = zeroToOne * 2.0;

          // 0 -> 2 에서 -1 -> +1 로 클립 공간 변환
          vec2 clipSpace = zeroToTwo - 1.0;

          // gl_Position은 정점 셰이더가 설정해 주어야 하는 내장 변수입니다.
          gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        }
      `;

      const fragmentShaderSource = `#version 300 es

        // 프래그먼트 셰이더는 기본 정밀도를 가지고 있지 않으므로 선언을 해야합니다.
        // highp는 기본값으로 적당합니다. "높은 정밀도(high precision)"를 의미합니다.
        precision highp float;

        // 프래그먼트 셰이더는 출력값을 선언 해야합니다.
        out vec4 outColor;

        void main() {
          // 붉은-보라색 상수로 출력값을 설정합니다.
          outColor = vec4(1, 0, 0.5, 1);
        }
      `;

      function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (success) {
          return shader;
        }
        console.log(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
      }

      function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        const success = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (success) {
          return program;
        }
        console.log(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
      }

      const vertexShader = createShader(
        gl,
        gl.VERTEX_SHADER,
        vertexShaderSource
      );
      const fragmentShader = createShader(
        gl,
        gl.FRAGMENT_SHADER,
        fragmentShaderSource
      );

      const program = createProgram(gl, vertexShader, fragmentShader);

      // 셰이더에서 사용할 attribute location 찾기
      const positionAttributeLocation = gl.getAttribLocation(
        program,
        'a_position'
      );

      // u_resolution 찾기
      const resolutionUniformLocation = gl.getUniformLocation(
        program,
        'u_resolution'
      );

      // Attribute는 버퍼에서 데이터를 가져오기 때문에 버퍼 생성
      const positionBuffer = gl.createBuffer();

      // positionBuffer 바인딩 하기
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

      // 세 개의 2d 점
      const positions = [10, 20, 80, 20, 10, 30, 10, 30, 80, 20, 80, 30];

      // bufferData를 통해 js의 positions을 GPU의 positionBuffer 로 복사
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(positions),
        gl.STATIC_DRAW
      );

      // attribute에게 데이터를 가져오는 방법 알리기, vao라고 불리는 attribute 상태 집합 생성
      const vao = gl.createVertexArray();

      // 아래 attribute 설정이 위 attribute 상태 집합에 적용되게 하기 위해 vertex array 생성하고 bind
      gl.bindVertexArray(vao);

      // vertext 활성화, WebGL에게 우리가 버퍼에서 데이터를 가져오려고 한다는 것을 알려주는 것. attribute을 켜지 않으면 attribute는 상수 값을 가지기 됩니다.
      gl.enableVertexAttribArray(positionAttributeLocation);

      const size = 2; // iteration마다 두개 구성 요소 사용
      const type = gl.FLOAT; // 데이터는 32비트 부동 소수점
      const normalize = false; // 데이터를 정규화하지 않음
      const stride = 0; // 0인 경우 실행할 때마다 `size * sizeof(type)`만큼 다음 위치로 이동합니다.
      const offset = 0; // 버퍼의 시작부터 데이터를 읽어옴

      // position ARRAY_BUFFER를 attribute에 바인딩
      gl.vertexAttribPointer(
        positionAttributeLocation,
        size,
        type,
        normalize,
        stride,
        offset
      );

      // canvas 설정
      resizeCanvasToDisplaySize(gl.canvas);

      // viewport 설정
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

      // canvas clear
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT);

      // 프로그램 사용
      gl.useProgram(program);

      // 셰이더 내에서 픽셀 위치를 클립 공간으로 변환 할 수 있도록 캔버스 해상도를 전달합니다.
      gl.uniform2f(
        resolutionUniformLocation,
        gl.canvas.width,
        gl.canvas.height
      );

      // attribute 바인딩
      gl.bindVertexArray(vao);

      // 그리기
      const primitiveType = gl.TRIANGLES;
      const drawOffset = 0; //
      const callCount = 6; // 정점 쉐이더 호출 카운트
      gl.drawArrays(primitiveType, drawOffset, callCount);
    </script>
  </body>
</html>
