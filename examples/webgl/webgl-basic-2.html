<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>WebGL Basic 2</title>
    <style>
      body {
        background-color: #fff;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
      }

      canvas {
        border: solid 1px #999;
      }
    </style>
  </head>
  <body>
    <div id="wrap" class="section">
      <h2>WebGL Basic 2</h2>
      <canvas id="canvas" width="400" height="400"></canvas>
    </div>
    <script type="module">
      // https://webgl2fundamentals.org/webgl/lessons/ko/webgl-fundamentals.html#toc
      import {
        createProgramFromSources,
        resizeCanvasToDisplaySize,
      } from '../../libs/webgl-utils.js';

      const vertexShaderSource = `#version 300 es

        // attribute는 정점 셰이더에 대한 입력(in)입니다.
        // 버퍼로부터 데이터를 받습니다.
        in vec2 a_position;

        uniform vec2 u_resolution;

        // 모든 셰이더는 main 함수를 가지고 있습니다.
        void main() {
          // 픽셀 위치를 0.0에서 1.0 사이 값으로 변환합니다.
          vec2 zeroToOne = a_position / u_resolution;

          // 0 -> 1에서 0 -> 2로 변환
          vec2 zeroToTwo = zeroToOne * 2.0;

          // 0 -> 2 에서 -1 -> +1 로 클립 공간 변환
          vec2 clipSpace = zeroToTwo - 1.0;

          // gl_Position은 정점 셰이더가 설정해 주어야 하는 내장 변수입니다.
          gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        }
      `;

      const fragmentShaderSource = `#version 300 es

        // 프래그먼트 셰이더는 기본 정밀도를 가지고 있지 않으므로 선언을 해야합니다.
        // highp는 기본값으로 적당합니다. "높은 정밀도(high precision)"를 의미합니다.
        precision highp float;

        uniform vec4 u_color;

        // 프래그먼트 셰이더는 출력값을 선언 해야합니다.
        out vec4 outColor;

        void main() {
          // 붉은-보라색 상수로 출력값을 설정합니다.
          outColor = u_color;
        }
      `;

      const canvas = document.getElementById('canvas');
      const gl = canvas.getContext('webgl2');

      const program = createProgramFromSources(gl, [
        vertexShaderSource,
        fragmentShaderSource,
      ]);

      // 셰이더에서 사용할 attribute location 찾기
      const positionAttributeLocation = gl.getAttribLocation(
        program,
        'a_position'
      );

      // u_resolution 찾기
      const resolutionUniformLocation = gl.getUniformLocation(
        program,
        'u_resolution'
      );

      const colorLocation = gl.getUniformLocation(program, 'u_color');

      // Attribute는 버퍼에서 데이터를 가져오기 때문에 버퍼 생성
      const positionBuffer = gl.createBuffer();

      // positionBuffer 바인딩 하기
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

      // 세 개의 2d 점
      const positions = [10, 20, 80, 20, 10, 30, 10, 30, 80, 20, 80, 30];

      // bufferData를 통해 js의 positions을 GPU의 positionBuffer 로 복사
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(positions),
        gl.STATIC_DRAW
      );

      // attribute에게 데이터를 가져오는 방법 알리기, vao라고 불리는 attribute 상태 집합 생성
      const vao = gl.createVertexArray();

      // 아래 attribute 설정이 위 attribute 상태 집합에 적용되게 하기 위해 vertex array 생성하고 bind
      gl.bindVertexArray(vao);

      // vertext 활성화, WebGL에게 우리가 버퍼에서 데이터를 가져오려고 한다는 것을 알려주는 것. attribute을 켜지 않으면 attribute는 상수 값을 가지기 됩니다.
      gl.enableVertexAttribArray(positionAttributeLocation);

      const size = 2; // iteration마다 두개 구성 요소 사용
      const type = gl.FLOAT; // 데이터는 32비트 부동 소수점
      const normalize = false; // 데이터를 정규화하지 않음
      const stride = 0; // 0인 경우 실행할 때마다 `size * sizeof(type)`만큼 다음 위치로 이동합니다.
      const offset = 0; // 버퍼의 시작부터 데이터를 읽어옴

      // position ARRAY_BUFFER를 attribute에 바인딩
      gl.vertexAttribPointer(
        positionAttributeLocation,
        size,
        type,
        normalize,
        stride,
        offset
      );

      // canvas 설정
      resizeCanvasToDisplaySize(gl.canvas);

      // viewport 설정
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

      // 프로그램 사용
      gl.useProgram(program);

      // attribute 바인딩
      gl.bindVertexArray(vao);

      // 셰이더 내에서 픽셀 위치를 클립 공간으로 변환 할 수 있도록 캔버스 해상도를 전달합니다.
      gl.uniform2f(
        resolutionUniformLocation,
        gl.canvas.width,
        gl.canvas.height
      );

      // 0과 (range - 1)사이의 정수를 반환합니다.
      function randomInt(range) {
        return Math.floor(Math.random() * range);
      }

      // 버퍼에 직사각형을 정의하는 값을 채웁니다.
      function setRectangle(gl, x, y, width, height) {
        var x1 = x;
        var x2 = x + width;
        var y1 = y;
        var y2 = y + height;

        // 참고: gl.bufferData(gl.ARRAY_BUFFER, ...)는 `ARRAY_BUFFER` 바인드 포인트에 어떤 버퍼가
        // 바인딩되었는지에 따라 영향을 받지만, 지금은 버퍼가 하나만 존재합니다.
        // 만일 버퍼가 여러개 있었다면 먼저 해당 버퍼를 `ARRAY_BUFFER`에 바인딩 해야만 합니다.

        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array([x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2]),
          gl.STATIC_DRAW
        );
      }

      for (let i = 0; i < 50; ++i) {
        const randomSize = randomInt(50);
        // 무작위 직사각형 설정
        setRectangle(
          gl,
          randomInt(gl.canvas.width),
          randomInt(gl.canvas.height),
          randomSize,
          randomSize
        );
        // 무작위 색상 설정
        gl.uniform4f(
          colorLocation,
          Math.random(),
          Math.random(),
          Math.random(),
          1
        );

        // 직사각형그리기
        // 삼각형 2개, 3 x 2 = 6, 사각형을 그리겠다.
        const primitiveType = gl.TRIANGLES;
        const drawOffset = 0; //
        const drawCount = 6; // 정점 쉐이더 호출 카운트
        gl.drawArrays(primitiveType, drawOffset, drawCount);
      }
    </script>
  </body>
</html>
